ðŸ”¹ Fix Options
âœ… Safer initial state

Instead of parseInt(...) || 0, explicitly check for null:

const getStoredNumber = (key) => {
  const value = localStorage.getItem(key);
  return value === null ? 0 : parseInt(value, 10) || 0;
};

const initialState = {
  counterAiReport: getStoredNumber("counterAiReport"),
  counterApiInteraction: getStoredNumber("counterApiInteraction"),
};


This avoids "null" or "undefined" strings messing you up.

âœ… Make SET_COUNTERS handle null safely
case "SET_COUNTERS": {
  const { counterAiReport, counterApiInteraction } = action.payload;

  const ai = counterAiReport ?? 0;          // default to 0 if null/undefined
  const api = counterApiInteraction ?? 0;

  localStorage.setItem("counterAiReport", ai);
  localStorage.setItem("counterApiInteraction", api);

  return {
    ...state,
    counterAiReport: ai,
    counterApiInteraction: api,
  };
}

âœ… Ensure API handling unwraps correctly

Right now youâ€™re checking:

if (res && res.data) {
  dispatch(setCounters(res.counter_ai_report, res.counter_interactions));
}


But res.data is the actual payload. If itâ€™s null, you should still dispatch zeros:

if (res && res.data) {
  const details = res.data;
  setCurrentPlan(details.plan);
  setPlanStatus(details.plan_status);
  dispatch(setCounters(details.counter_ai_report, details.counter_interactions));
} else {
  // API returned null â†’ reset counters
  dispatch(setCounters(0, 0));
}
